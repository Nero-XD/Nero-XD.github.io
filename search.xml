<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PAT甲级</title>
    <url>/2021/09/21/PAT%E7%94%B2%E7%BA%A7/</url>
    <content><![CDATA[<p>将会持续更新PAT甲级题解直到12月考完。</p>
<p>如果哪里解法有疑问可以直接找博主询问。</p>
<p>可点击右边目录快捷跳转。</p>
<h2 id="1001-A-B-Format"><a href="#1001-A-B-Format" class="headerlink" title="1001 A+B Format"></a><strong>1001 A+B Format</strong></h2><p>题意：</p>
<p>​        给定两个$[-10^6,10^6]$内的整数，按要求格式输出他们的和</p>
<p>思路：</p>
<p>​        先用按$int$形式读入两个数，相加后转为$string$，然后不计负号每三位（离数的结尾）输出一个逗号。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> c = a + b;</span><br><span class="line">	s = <span class="built_in">to_string</span>(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		cout &lt;&lt; s[i];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((s.<span class="built_in">size</span>() - (i + <span class="number">1</span>)) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i != s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1002-A-B-for-Polynomials"><a href="#1002-A-B-for-Polynomials" class="headerlink" title="1002 A+B for Polynomials"></a><strong>1002 A+B for Polynomials</strong></h2><p>题意：</p>
<p>​        给定两个多项式，求出其相乘后的结果。</p>
<p>思路：</p>
<p>​        模拟手算多项式乘法，由于浮点误差，写个$eps$来判断是否为0。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">zero</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (-eps &lt;= x &amp;&amp; x &lt;= eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">double</span> y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[x] = y;</span><br><span class="line">        flag[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">double</span> y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        b[x] = y;</span><br><span class="line">        flag[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; &gt;ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123; i,a[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d %.1f&quot;</span>, i.first, i.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1003-Emergency"><a href="#1003-Emergency" class="headerlink" title="1003 Emergency"></a><strong>1003 Emergency</strong></h2><p>题意：</p>
<p>​        给定一个图，求出其$C_1$到$C_2$最短路的长度和最短路的数量。</p>
<p>思路：</p>
<p>​        $Dijkstra$板子题</p>
<p>代码：</p>
<p>​        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, op, ed;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, len;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(&#123; v,len &#125;);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(&#123; u,len &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn], val[maxn], cnt[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, ds;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ds &gt; b.ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, inf, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    dis[op] = <span class="number">0</span>, val[op] = num[op], cnt[op] = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;node&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123; op,<span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> u = now.u, ds = now.ds;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : G[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.v, len = i.len;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + len &lt; dis[v]) &#123;</span><br><span class="line">                cnt[v] = cnt[u];</span><br><span class="line">                dis[v] = dis[u] + len;</span><br><span class="line">                val[v] = val[u] + num[v];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123; v,dis[v] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dis[u] + len == dis[v]) &#123;</span><br><span class="line">                cnt[v] += cnt[u];</span><br><span class="line">                val[v] = <span class="built_in">max</span>(val[v], val[u] + num[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;op, &amp;ed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, len;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;len);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, cnt[ed], val[ed]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1004-Counting-Leaves"><a href="#1004-Counting-Leaves" class="headerlink" title="1004 Counting Leaves"></a><strong>1004 Counting Leaves</strong></h2><p>题意：</p>
<p>​        给定一棵树，求出每层中叶子节点的数量，树的根节点为01。</p>
<p>思路：</p>
<p>​        按层$bfs$一遍即可得到每层有多少个叶子节点。</p>
<p>代码：</p>
<p>​        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], dep;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(op);</span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ++dep;</span><br><span class="line">        <span class="keyword">int</span> goal = que.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= goal;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (G[u].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[dep]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dep = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= dep;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != dep) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1005-Spell-It-Right"><a href="#1005-Spell-It-Right" class="headerlink" title="1005 Spell It Right"></a><strong>1005 Spell It Right</strong></h2><p>题意：</p>
<p>​        给出一个一百位以内的树，求出其所有位数之和，并用英文输出这个和的每一位。</p>
<p>思路：</p>
<p>​        简单模拟。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string num[<span class="number">10</span>] = &#123; <span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span> &#125;;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">        sum += i - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(num[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sum) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(num[sum % <span class="number">10</span>]);</span><br><span class="line">        sum /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">        <span class="keyword">if</span> (i != ans.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1006-Sign-In-and-Sign-Out"><a href="#1006-Sign-In-and-Sign-Out" class="headerlink" title="1006 Sign In and Sign Out"></a><strong>1006 Sign In and Sign Out</strong></h2><p>题意：</p>
<p>​        给定一些$ID$和它对应的登录时间登出时间，求哪个$ID$最早登入，哪个$ID$最晚登出。</p>
<p>思路：</p>
<p>​        将登入时间和等处时间分别进行排序，分别选取最小值和最大值，记录$ID$并输出。</p>
<p>代码：</p>
<p>​        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, m, s;</span><br><span class="line">&#125;b[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node&amp; a, node&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.h != b.h) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.h &lt; b.h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.m != b.m) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.m &lt; b.m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">string a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> op, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>, &amp;b[i].h, &amp;b[i].m, &amp;b[i].s);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d&quot;</span>, &amp;c[i].h, &amp;c[i].m, &amp;c[i].s);</span><br><span class="line">    &#125;</span><br><span class="line">    op = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">    b[<span class="number">0</span>] = &#123; <span class="number">23</span>,<span class="number">59</span>,<span class="number">59</span> &#125;, c[<span class="number">0</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(b[i], b[op])) &#123;</span><br><span class="line">            op = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(c[ed], c[i])) &#123;</span><br><span class="line">            ed = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[op] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[ed];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1007-Maximum-Subsequence-Sum"><a href="#1007-Maximum-Subsequence-Sum" class="headerlink" title="1007 Maximum Subsequence Sum"></a><strong>1007 Maximum Subsequence Sum</strong></h2><p>题意：</p>
<p>​        给定一组数，求其最大子段和，并求出其对应的区间。</p>
<p>思路：</p>
<p>​        线性DP板子题。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn], l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= <span class="number">0</span>) flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, <span class="number">0</span>, arr[<span class="number">1</span>], arr[n]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mx = arr[<span class="number">1</span>], sum = <span class="number">0</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> al = <span class="number">1</span>, ar = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            l = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; mx) &#123;</span><br><span class="line">            mx = sum;</span><br><span class="line">            al = l, ar = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx == <span class="number">0</span>) al = ar = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//测试点5：全为负数和0</span></span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="comment">//-1 0 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, mx, arr[al], arr[ar]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1008-Elevator"><a href="#1008-Elevator" class="headerlink" title="1008 Elevator"></a><strong>1008 Elevator</strong></h2><p>题意：</p>
<p>​        有一个电梯，上升一层耗时$6s$，下降一层耗时$4s$，在目标层停驻$5s$，求按给定层数移动共需要多长时间。</p>
<p>思路：</p>
<p>​        简单模拟。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        ans += arr[i] &gt; arr[i - <span class="number">1</span>] ? (arr[i] - arr[i - <span class="number">1</span>]) * <span class="number">6</span> : (arr[i - <span class="number">1</span>] - arr[i]) * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n * <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1009-Product-of-Polynomials"><a href="#1009-Product-of-Polynomials" class="headerlink" title="1009 Product of Polynomials"></a><strong>1009 Product of Polynomials</strong></h2><p>题意：</p>
<p>​        给定两个多项式，求出其相乘的结果。</p>
<p>思路：</p>
<p>​        由于每个多项式最大只有1000次方，所以乘起来最大也就2000次方，所以开个</p>
<p>2000大小的数组模拟一下就行了。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">double</span> vala[maxn], valb[maxn], valc[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jg</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (-eps &lt; x &amp;&amp; x &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;a[i], &amp;vala[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;b[i], &amp;valb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) &#123;</span><br><span class="line">            valc[a[i] + b[j]] += vala[i] * valb[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2000</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">jg</span>(valc[i])) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (ans.size() == 0) &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;1 0 0&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d %.1f&quot;</span>, i, valc[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1010-Radix"><a href="#1010-Radix" class="headerlink" title="#1010 Radix"></a><strong>#1010 Radix</strong></h2><p>还没拿满分，等改好了再来填这个坑</p>
<h2 id="1011-World-Cup-Betting"><a href="#1011-World-Cup-Betting" class="headerlink" title="1011 World Cup Betting"></a><strong>1011 World Cup Betting</strong></h2><p>题意：</p>
<p>​        给定三行的$W,T,L$,选取每行中最大的那个记录下来，并按题目给出的公式进行计算。</p>
<p>思路：</p>
<p>​        考察语法基础。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>] = &#123; <span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;L&#x27;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt;ans;</span><br><span class="line">    <span class="keyword">double</span> out = <span class="number">0.65</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> x[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> mx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[j] &gt; mx) &#123;</span><br><span class="line">                mx = x[j], index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(s[index]);</span><br><span class="line">        out *= mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c %c %.2f&quot;</span>, ans[<span class="number">0</span>], ans[<span class="number">1</span>], ans[<span class="number">2</span>], (out - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1012-The-Best-Rank"><a href="#1012-The-Best-Rank" class="headerlink" title="1012 The Best Rank"></a><strong>1012 The Best Rank</strong></h2><p>题意：</p>
<p>​        给定$n$个学生的$id$和三门成绩和$m$次查询，每次询问给定一个$id$，问其对应的学生哪门课排名最高，若有排名相同的，按题目给定优先级选取优先级最高的。</p>
<p>思路：</p>
<p>​        排序四次，分别求出四种分数的排名，在最后一次排序后用哈希表存下对应$id$，最后按要求出书。</p>
<p>小技巧：</p>
<p>​        设一个全局变量，在写$cmp$函数时按数组编号来排序，可以只写一个$cmp$函数。</p>
<p>代码：</p>
<p>​        </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2e3 + 10;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int no, data[4], rank[4];</span><br><span class="line">    int best;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">int k;</span><br><span class="line">bool cmp(node&amp; x, node&amp; y) &#123;</span><br><span class="line">    return x.data[k] &gt; y.data[k];</span><br><span class="line">&#125;</span><br><span class="line">int mp[1000010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i = 1;i &lt;= n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i].no);</span><br><span class="line">        for (int j = 1;j &lt;= 3;j++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i].data[j]);</span><br><span class="line">            a[i].data[0] += a[i].data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0;i &lt;= 3;i++) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        sort(a + 1, a + 1 + n, cmp);</span><br><span class="line">        a[1].rank[i] = 1;</span><br><span class="line">        for (int j = 2;j &lt;= n;j++) &#123;</span><br><span class="line">            a[j].rank[i] = (a[j].data[i] == a[j - 1].data[i]) ? a[j - 1].rank[i] : j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1;i &lt;= n;i++) &#123;</span><br><span class="line">        mp[a[i].no] = i;</span><br><span class="line">        int mx = n + 1;</span><br><span class="line">        for (int j = 0;j &lt;= 3;j++) &#123;</span><br><span class="line">            if (a[i].rank[j] &lt; mx) &#123;</span><br><span class="line">                mx = a[i].rank[j];</span><br><span class="line">                a[i].best = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char ans[4] = &#123; &#x27;A&#x27;,&#x27;C&#x27;,&#x27;M&#x27;,&#x27;E&#x27; &#125;;</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;s);</span><br><span class="line">        if (!mp[s]) &#123;</span><br><span class="line">            printf(&quot;N/A\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int index = mp[s];</span><br><span class="line">            printf(&quot;%d %c\n&quot;, a[index].rank[a[index].best], ans[a[index].best]);</span><br><span class="line">        &#125;</span><br><span class="line">        // if (m) &#123;</span><br><span class="line">        //     printf(&quot;\n&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1013-Battle-Over-Cities"><a href="#1013-Battle-Over-Cities" class="headerlink" title="1013 Battle Over Cities"></a><strong>1013 Battle Over Cities</strong></h2><p>题意：</p>
<p>​        给定一个无向图，有$n$个节点，$m$条变，$k$次询问，每次询问中给出一个节点的编号，问去除这个节点后剩下的图中有的多少联通块。</p>
<p>思路：</p>
<p>​        1、写一个并查集，每次删除点后把所有点重新进行一次合并，最后看有多少个连通块，答案是连通块数量减二（因为要删除的点单独形成了一个连通块，而把剩余$ans-1$个连通块合在一起只要$ans-2$条边）。</p>
<p>​        2、和并查集类似，每次在删除一个点后，从$1$到$n$，若没有遍历过就进行一次$dfs$，最后统计进行了几次$dfs$即可。</p>
<p>代码$(dsu)$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">vector &lt;P&gt;edge;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? fa[x] : (fa[x] = <span class="built_in">Find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">Find</span>(x)] = <span class="built_in">Find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		edge.<span class="built_in">push_back</span>(&#123; u,v &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> e : edge) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e.first == x || e.second == x) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">Union</span>(e.first, e.second);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fa[i] == i) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans - <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1014-Waiting-in-Line"><a href="#1014-Waiting-in-Line" class="headerlink" title="1014 Waiting in Line"></a><strong>1014 Waiting in Line</strong></h2><p>题意：</p>
<p>​    给定$n$个队列，每个队列最多可以存$m$个元素，现有$k$个客人，每个客人会选择队列最少且编号最小的队伍入队，并且每个人消耗一定的时间后才能出队，给出$q$次询问，问给出编号的人什么时候出队，如果这个人入队的时间超过了下午五点，那么输出$Sorry$。</p>
<p>思路：</p>
<p>​    用结构体加队列模拟题目所述情况，结构体中要存放队伍中第一个人的出队时间，好确定下一个人入的是哪个队，还要存最后一个人的结束时间，用来确定下一个人什么时候开始。最后用优先队列实现去除第一个人结束最早的那个队列。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> poptime, endtime, index;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> poptime != b.poptime ? poptime &gt; b.poptime:index &gt; b.index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;line[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m &amp;&amp; cnt &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n &amp;&amp; cnt &lt; k;j++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            line[j].que.<span class="built_in">push</span>(x);</span><br><span class="line">            line[j].endtime += x;</span><br><span class="line">            ans[cnt] = line[j].endtime;</span><br><span class="line">            <span class="keyword">if</span> (line[j].endtime - x &gt;= <span class="number">540</span>) ans[cnt] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                line[j].poptime = x;</span><br><span class="line">                line[j].que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;node&gt;pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        line[i].index = i;</span><br><span class="line">        pq.<span class="built_in">push</span>(line[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        cnt++;</span><br><span class="line">        node temp = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        temp.que.<span class="built_in">push</span>(x);</span><br><span class="line">        temp.poptime += temp.que.<span class="built_in">front</span>();</span><br><span class="line">        temp.que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.endtime += x;</span><br><span class="line">        ans[cnt] = temp.endtime;</span><br><span class="line">        <span class="keyword">if</span> (temp.endtime - x &gt;= <span class="number">540</span>) ans[cnt] = <span class="number">-1</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (ans[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Sorry&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>, (ans[x] + <span class="number">480</span>) / <span class="number">60</span>, (ans[x] + <span class="number">480</span>) % <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1015-Reversible-Primes"><a href="#1015-Reversible-Primes" class="headerlink" title="1015 Reversible Primes"></a><strong>1015 Reversible Primes</strong></h2><p>题意：</p>
<p>​    给定两个数字$n$和$D$，问$n$在$D$进制下表示出来后倒置后的数转换为十进制后是否为质数，若原数和处理后的数都为质数就输出$Yes$，否则输出$No$。多组输入，以输入负数结尾。</p>
<p>思路：</p>
<p>​    递归倒置一下就可以了。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>;i * i &lt;= x;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll n, d;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(ll n, ll&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = x * d + n % d;</span><br><span class="line">    <span class="built_in">fun</span>(n / d, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">    ll x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fun</span>(n, x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_prime</span>(x) &amp;&amp; <span class="built_in">is_prime</span>(n))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n) &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>())</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1016-Phone-Bills"><a href="#1016-Phone-Bills" class="headerlink" title="1016 Phone Bills"></a><strong>1016 Phone Bills</strong></h2><p>题意：</p>
<p>​    第一行给出每个小时内（24个）每分钟通话消耗的价钱，第二行给出一个$n$，接下来的$n$行每行有一条信息，由姓名、通话月/日/小时/分钟，开始/结束组成，保证每个样例中的信息都在同一个月里，按题目给定要求输出每个人在这个月内的账单。</p>
<p>解法：</p>
<p>​    按姓名为第一关键字，时间为第二关键字进行排序，选取相邻的两个中前一个上线，后一个下线的信息组成一对，然后按题目要求计算费用后输出。关于计算费用，由于PAT中数据都比较小，所以直接是一分钟一分钟的加上去来暴力计算费用的。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> d, h, m;</span><br><span class="line">    <span class="keyword">bool</span> on;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node b)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != b.name) <span class="keyword">return</span> name &lt; b.name;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cal</span>(d, h, m, b.d, b.h, b.m) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, h, m;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Time&gt;op, ed;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTime</span><span class="params">(Time a, Time b, <span class="keyword">double</span>&amp; Amount)</span> </span>&#123;</span><br><span class="line">    Amount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a.d != b.d || a.h != b.h || a.m != b.m) &#123;</span><br><span class="line">        Amount += cost[a.h + <span class="number">1</span>];</span><br><span class="line">        ret++;</span><br><span class="line">        a.m++;</span><br><span class="line">        <span class="keyword">if</span> (a.m == <span class="number">60</span>) &#123;</span><br><span class="line">            a.m = <span class="number">0</span>;</span><br><span class="line">            a.h++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.h == <span class="number">24</span>) &#123;</span><br><span class="line">            a.h = <span class="number">0</span>;</span><br><span class="line">            a.d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Amount /= <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; op.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> temp;</span><br><span class="line">        <span class="keyword">int</span> TCost = <span class="built_in">GetTime</span>(op[i], ed[i], temp);</span><br><span class="line">        tot += temp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d &quot;</span>, op[i].d, op[i].h, op[i].m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d &quot;</span>, ed[i].d, ed[i].h, ed[i].m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f\n&quot;</span>, TCost, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2f\n&quot;</span>, tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">24</span>;i++) cin &gt;&gt; cost[i];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%02d%*c%02d%*c%02d%*c%02d&quot;</span>, &amp;month, &amp;a[i].d, &amp;a[i].h, &amp;a[i].m);</span><br><span class="line">        string temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (temp[<span class="number">1</span>] == <span class="string">&#x27;f&#x27;</span>) a[i].on = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i].on = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &lt; n) &amp;&amp; (a[i].name == a[i + <span class="number">1</span>].name) &amp;&amp; a[i].on &amp;&amp; (!a[i + <span class="number">1</span>].on)) &#123;</span><br><span class="line">            op.<span class="built_in">push_back</span>(&#123; a[i].d,a[i].h,a[i].m &#125;);</span><br><span class="line">            ed.<span class="built_in">push_back</span>(&#123; a[i + <span class="number">1</span>].d,a[i + <span class="number">1</span>].h,a[i + <span class="number">1</span>].m &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((i == n) || (a[i].name != a[i + <span class="number">1</span>].name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; a[i].name;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %02d\n&quot;</span>, month);</span><br><span class="line">                <span class="built_in">show</span>();</span><br><span class="line">                op.<span class="built_in">clear</span>();</span><br><span class="line">                ed.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1017-Queueing-at-Bank"><a href="#1017-Queueing-at-Bank" class="headerlink" title="1017 Queueing at Bank"></a><strong>1017 Queueing at Bank</strong></h2><p>题意：</p>
<p>​    有$n$个客户和$k$个窗口，每个窗口可以站一个客户，给出每个客户的到达时间和花费时间，问客户的平均等待时间是多少。*营业时间是$[8:00:00,17:00:00)$，在开始前到的话要等到开始营业，在结束后到的话不纳入处理范围。</p>
<p>思路：</p>
<p>​    全部换算成秒，然后按时间进行排序，用优先队列模拟窗口。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;P&gt;arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, m, s, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%*c%d%*c%d %d&quot;</span>, &amp;h, &amp;m, &amp;s, &amp;c);</span><br><span class="line">        arr.<span class="built_in">push_back</span>(&#123; h * <span class="number">3600</span> + m * <span class="number">60</span> + s,c * <span class="number">60</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;que;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.first &gt;= <span class="number">61200</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (it.first &lt; <span class="number">28800</span>) &#123;</span><br><span class="line">            sum += <span class="number">28800</span> - it.first;</span><br><span class="line">            it.first = <span class="number">28800</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (que.<span class="built_in">size</span>() &lt; m) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(it.first + it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (que.<span class="built_in">size</span>() == m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">top</span>() &gt; it.first) &#123;</span><br><span class="line">                sum += que.<span class="built_in">top</span>() - it.first;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">max</span>(que.<span class="built_in">top</span>(), it.first) + it.second);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, sum / <span class="number">60.0</span> / cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1018-Public-Bike-Management"><a href="#1018-Public-Bike-Management" class="headerlink" title="1018 Public Bike Management"></a><strong>1018 Public Bike Management</strong></h2><p>题意:</p>
<p>​    给定一个无向图，给定终点，每个点最大存储量，定义若该节点自行车数量若为最大存储量的一般，则为$perfect$，在路过节点时，我们会把不满足$perfect$的点调整至$perfect$，如果是少了，就会从带着的车中拿出一部分加入该节点，若多了，就会将该节点中的一部分加入自己带着的车，在起点时我们可以带一部分车，按题意可视为我们只走到终点，不回头。以0为起点，问到达终点路径最短的路径是什么，若有多条，选取需要从起点带走自行车最少的路，若仍有多条，则选取要带回去自行车最少的路。</p>
<p>思路：</p>
<p>​    用$Dijkstra$求出最短路，然后用$dfs$求出满足题目要求的路径并记录下来。*$dfs$中加入了一个小剪枝，不然这个代码↓会$TLE$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;P&gt;G[maxn];</span><br><span class="line"><span class="keyword">int</span> lim, n, ed, m;</span><br><span class="line"><span class="keyword">int</span> bike[maxn], mn;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Vis[maxn] = &#123;&#125;;</span><br><span class="line">    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    Vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        P top = que.<span class="built_in">top</span>();</span><br><span class="line">        Vis[top.second] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (top.second == ed) &#123;</span><br><span class="line">            <span class="keyword">while</span> (que.<span class="built_in">size</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> top.first;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : G[top.second]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = it.first, w = it.second;</span><br><span class="line">            <span class="keyword">if</span> (Vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> D = w + top.first;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(D, v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minneed, minback;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;ans, path;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dis, <span class="keyword">int</span> need, <span class="keyword">int</span> back)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; mn) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == ed &amp;&amp; dis == mn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minneed == <span class="number">-1</span> || need &lt; minneed || (need == minneed &amp;&amp; back &lt; minback)) &#123;</span><br><span class="line">            minneed = need;</span><br><span class="line">            minback = back;</span><br><span class="line">            ans = path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : G[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = it.first, w = it.second;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> tn = need, tb = back;</span><br><span class="line">            <span class="keyword">if</span> (bike[v] &lt; lim) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = lim - bike[v];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; back) &#123;</span><br><span class="line">                    back -= temp;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp -= back;</span><br><span class="line">                    back = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                need += temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bike[v] &gt; lim) &#123;</span><br><span class="line">                back += bike[v] - lim;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(v);</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v, dis + w, need, back);</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">            need = tn, back = tb;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;lim, &amp;n, &amp;ed, &amp;m);</span><br><span class="line">    lim /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bike[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v, w));</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u, w));</span><br><span class="line">    &#125;</span><br><span class="line">    mn = <span class="built_in">dijkstra</span>();</span><br><span class="line">    minneed = minback = <span class="number">-1</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 0&quot;</span>, minneed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt;%d&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, minback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1019-General-Palindromic-Number"><a href="#1019-General-Palindromic-Number" class="headerlink" title="1019 General Palindromic Number"></a><strong>1019 General Palindromic Number</strong></h2><p>题意：</p>
<p>​    给定两个数字$n$和$b$，要求出$n$在$b$进制下的数，并判断其是否是回文数。</p>
<p>思路：</p>
<p>​    进制转换就是取模和除，注意转换后的数组的方向。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;arr;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(n % m);</span><br><span class="line">        n /= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != arr[arr.<span class="built_in">size</span>() - i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1020-Tree-Traversals"><a href="#1020-Tree-Traversals" class="headerlink" title="1020 Tree Traversals"></a><strong>1020 Tree Traversals</strong></h2><p>题意：</p>
<p>​    给出一颗二叉树的后序遍历和中序遍历，求层序遍历。</p>
<p>思路：</p>
<p>​    递归思想，根据后续遍历和中序遍历的特征，每次递归当前节点的左子树和右子树。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;G[maxn];</span><br><span class="line"><span class="keyword">int</span> n, post[maxn], in[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">    G[pre].<span class="built_in">push_back</span>(post[pr]);</span><br><span class="line">    <span class="keyword">if</span> (pl == pr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> im = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = il;i &lt;= ir;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == post[pr]) &#123;</span><br><span class="line">            im = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> llen = im - il, rlen = ir - im;</span><br><span class="line">    <span class="keyword">if</span> (llen) <span class="built_in">dfs</span>(in[im], pl, pl + llen - <span class="number">1</span>, il, im - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rlen) <span class="built_in">dfs</span>(in[im], pl + llen, pr - <span class="number">1</span>, im + <span class="number">1</span>, ir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(u);</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;post[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, n, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; ans.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT甲级</category>
      </categories>
      <tags>
        <tag>PAT甲级</tag>
      </tags>
  </entry>
  <entry>
    <title>今日落日</title>
    <url>/2021/09/20/%E8%90%BD%E6%97%A5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/09/20/KCEvRrNi5Z3AhBV.jpg" alt="落日"></p>
<p>摄于2021/9/20 PM6：01</p>
]]></content>
      <categories>
        <category>DailyLife</category>
      </categories>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title>数论入门</title>
    <url>/2021/09/21/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><!-- toc -->

<h3 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h3><h4 id="算数基本定理（唯一分解定理）"><a href="#算数基本定理（唯一分解定理）" class="headerlink" title="算数基本定理（唯一分解定理）"></a>算数基本定理（唯一分解定理）</h4><p>设正整数$a$，那么必有表示：</p>
<p>$a=p_1p_2…p_s$</p>
<p>其中$p_j(1\leq j\leq s)$是素数。并且在不计次序的意义下，该表示唯一。</p>
<p>将上述表示中，相同素数合并后，可得：</p>
<p>$a=p_1^{α_1}p_2^{α_2}…p_s^{α_s},p_1&lt;p_2&lt;…p_s$</p>
<p>称为正整数$a$的标准因数分解式</p>
<h4 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h4><p>同余的定义：设整数$m!=0$。若$m|a-b$，称$m$为模数（模），$a$同余于$b$模$m$，$b$是$a$对模$m$的剩余$$。记作：</p>
<p>$a\equiv b\ (mod\ m)$</p>
<p>否则$a\ne b\ (mod\ m)$</p>
<p><strong>同余的性质：</strong></p>
<p>整数$a$同余于整数$b$模$m$，等价于$a$和$b$被$m$除，余数相等。</p>
<p>同余式可以相加减，可以相乘。</p>
<p>设正整数$d$整除$m$。如果$a$与$b$模$m$同余，则他们模$d$也同余。</p>
<p>设$d$为整数，则</p>
<p>$a\equiv b\ (mod\ m)$</p>
<p>等价于</p>
<p>$da\equiv db\ (mod\ dm)$</p>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h4 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h4><h5 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h5><p>复杂度$O(\sqrt{n})$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= x;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Miller-Rabin-素性测试"><a href="#Miller-Rabin-素性测试" class="headerlink" title="*$Miller\ Rabin$ 素性测试"></a>*$Miller\ Rabin$ 素性测试</h5><p>$Miller\ Rabin$ 素性测试$(Miller\ Rabin\ primality\ test)$是进阶的素数判定方法。 对数 $n $进行 $k$ 轮测试的时间复杂度是 $O(k\ log^3n)$。</p>
<p>*利用 FFT 等技术可以优化到$O(k\ log^2n\ loglog\ n\ logloglog\ n)$   <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Complexity">证明链接</a></p>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>最大公约数即为 $Greatest\ Common\ Divisor$ ，常缩写为$gcd$。</p>
<h4 id="互素的性质与最大公约数理论：裴蜀定理"><a href="#互素的性质与最大公约数理论：裴蜀定理" class="headerlink" title="互素的性质与最大公约数理论：裴蜀定理"></a>互素的性质与最大公约数理论：裴蜀定理</h4><p>设$a,b$是不全为零的整数，则存在整数$x,y$，使得$ax+by=gcd(a,b)$</p>
<p><a href="https://oi-wiki.org/math/number-theory/bezouts/">证明链接</a></p>
<h4 id="辗转相除法（欧几里得算法）"><a href="#辗转相除法（欧几里得算法）" class="headerlink" title="辗转相除法（欧几里得算法）"></a>辗转相除法（欧几里得算法）</h4><p>又叫 $Euclid$ 算法，求最大公约数的算法</p>
<p>原理为易证的$gcd(a,b)=gcd(b,a\ mod\ b)$</p>
<p>$algorithm$库中有内置的$gcd$模板:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__gcd(a, b)</span><br></pre></td></tr></table></figure>

<p>手写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? y : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其时间复杂度（最大）为$O(log\ n)$，当用其求斐波那契数列相邻两项的$gcd$时到达最坏复杂度</p>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>扩展欧几里得算法$(Extended\ Euclidean\ algorithm,EXGCD)$常用于求$ax+by=gcd(a,b)$的一组可行解。</p>
<p>证明：<br>$$<br>ax_1+by_1=gcd(a,b)<br>$$</p>
<p>$$<br>bx_2+(a\ mod\ b)y_2=gcd(b,a\ mod\ b)<br>$$</p>
<p>$$<br>由欧几里得定理可知:gcd(a,b)=gcd(b,a\ mod\ b)<br>$$</p>
<p>$$<br>∴ax_1+by_1=bx_2+(a\ mod\ b)y_2<br>$$</p>
<p>$$<br>又∵a\ mod\ b=a-(\lfloor \frac{a}{b}\rfloor×b )<br>$$</p>
<p>$$<br>∴ax_1+by_1=bx_2+(a-(\lfloor \frac{a}{b}\rfloor × b)y_2)<br>$$</p>
<p>$$<br>移相得a(x_1-y_2)+b(y_1-x_2+\lfloor\frac{a}{b}\rfloor y_2)=0<br>$$</p>
<p>$$<br>∴x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor y_2<br>$$</p>
<p>将$x_2,y_2$不断带入递归求解直至$gcd$为$0$递归$x=1,y=0$回去求解（此时得到的$|x|+|y|的值为最小，且x&lt;y$</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> tempy = y;</span><br><span class="line">    y = x - a / b * y;</span><br><span class="line">    x = tempy;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="欧拉函数的定义"><a href="#欧拉函数的定义" class="headerlink" title="欧拉函数的定义"></a>欧拉函数的定义</h4><p>欧拉函数$(Euler’s\ totient\ function)$，即$ \varphi(n)$，表示的是小于等于$n$且和$n$互质的数的个数，比如说$ \varphi(1)=1$。</p>
<p>当$n$含有的不同质因子又$p_1,p_2,…,p_m$，则$ \varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_m})$</p>
<p>代码实现求<strong>单个数</strong>的欧拉函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ret = ret / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//由于n是在不断变化的，所以最后的时候n可能还有质因子没处理完就结束循环</span></span><br><span class="line">    <span class="comment">//所以这里要补一刀</span></span><br><span class="line">    <span class="comment">//n此时必定是质数</span></span><br><span class="line">    <span class="comment">//如果是合数，那么循环不会结束(带入看一下就知道了)</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当$n$是质数的时候，显然有$ \varphi(n)=n-1$</p>
<h4 id="欧拉函数的一些性质"><a href="#欧拉函数的一些性质" class="headerlink" title="欧拉函数的一些性质"></a>欧拉函数的一些性质</h4><p><strong>Ⅰ</strong>    欧拉函数是积性函数。</p>
<p>​      *积性函数：若$a$和$b$互质，那么$f(a×b)=f(a)×f(b)$</p>
<p>​      **完全积性函数：$f(a×b)=f(a)×f(b)$</p>
<p><strong>Ⅱ</strong>    $n=\sum_{d|n} \varphi(d)$</p>
<p>​      *待补充</p>
<p><strong>Ⅲ</strong>  若$n=p^k$，其中$p$是质数，那么$ \varphi(n)=p^k-p^{k-1}$</p>
<p>​       ↑因为除了$p$的倍数外，其他的数都跟$n$互质</p>
<h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><h4 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h4><h5 id="埃氏筛（埃拉托斯特尼筛法）"><a href="#埃氏筛（埃拉托斯特尼筛法）" class="headerlink" title="埃氏筛（埃拉托斯特尼筛法）"></a>埃氏筛（埃拉托斯特尼筛法）</h5><p>如果$x$是合数，那么$x$的倍数也一定是合数，因此我们可以去除掉很多次不必要的检测。</p>
<p>从小到大考虑每个数，然后把当前数的所有倍数标记为合数，那么运行完后未被标记的数就是质数。</p>
<p>*避免使用vector<bool></bool></p>
<p>  不要用vector<bool>，他会被自动优化成类似bitset的伪容器</bool></p>
<p>  虽然空间变小了，但是花的时间会变多，而且由于C++是按照byte来寻址</p>
<p>  它只占用1bit（8 bit=1 byte），指向一位的指针是非法的，所以不能对vector地址进行解引用的操作</p>
<p>  因此，对vecotr<bool>的使用需慎重考虑以下几点：</bool></p>
<p>  (1)是否需要牺牲速度来获取空间上的优化</p>
<p>  (2)算法中会否有对vector地址进行解引用操作的可能。</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt;<span class="built_in">is_prime</span>(n + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i;j &lt;= n;j += i) &#123;</span><br><span class="line">                is_prime[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为$n\ loglog\ n$。</p>
<p><strong>优化方案</strong></p>
<p>①筛至平方更，时间复杂度会变为$n\ ln\ ln\sqrt{n}$</p>
<p>②只筛奇数</p>
<p>③分块筛选（将空间复杂度从$O(n)$优化为了$O(\sqrt{n}+S)$）</p>
<p>​    代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> nsqrt = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt;<span class="built_in">is_prime</span>(nsqrt + <span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= nsqrt;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i;j &lt;= nsqrt;j += i) &#123;</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt;<span class="built_in">block</span>(S + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k * S &lt;= n;k++) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(block.<span class="built_in">begin</span>(), block.<span class="built_in">end</span>(), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> op = k * S, ed = <span class="built_in">min</span>(op + S, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : prime) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = (op + p - <span class="number">1</span>) / p;<span class="comment">//第一个大于等于op的p的倍数</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">max</span>(p, start) * p - op;</span><br><span class="line">            <span class="comment">//取max是类似欧拉筛，避免了重复筛数</span></span><br><span class="line">            <span class="comment">//同时如果start等于0时,会将自己筛掉，减少答案的个数</span></span><br><span class="line">            <span class="keyword">for</span> (;j &lt; ed - op;j += p)</span><br><span class="line">                block[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) block[<span class="number">0</span>] = block[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ed - op;i++)</span><br><span class="line">            <span class="keyword">if</span> (block[i])</span><br><span class="line">                ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    分块筛的渐进时间复杂度与埃氏筛一样（除非块非常小），但内存更小，丙炔有    更好的缓存结果。另一方面，对于每一    对块和区间$[1,\sqrt{n}]$中的要素都要进行除        法，儿对于较小的块来说，这种情况要糟糕得多。因此，在选择常数S时要保持    平衡。块大小S取$10^4$到$10^5$之间，可以获得最佳的速度。</p>
<h5 id="欧拉筛法（线性筛法）"><a href="#欧拉筛法（线性筛法）" class="headerlink" title="欧拉筛法（线性筛法）"></a>欧拉筛法（线性筛法）</h5><p>由于埃氏筛会把一个合数重复筛多次（自己的所有质因子的数量次），如果让每个合数都只被标记一次，那么时间复杂度就会降到$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, vis[maxn], prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; (<span class="number">1ll</span> * i * prime[j] &lt;= n);j++) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % prime[j])) &#123;</span><br><span class="line">                <span class="comment">//i被prime[j]筛过</span></span><br><span class="line">                <span class="comment">//所以i再乘上比prime[j]大的质数也是prime[j]的倍数</span></span><br><span class="line">                <span class="comment">//他们都被prime[j]的倍数，所以不需要再筛了</span></span><br><span class="line">                <span class="comment">//所以break掉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="欧拉筛求欧拉函数"><a href="#欧拉筛求欧拉函数" class="headerlink" title="欧拉筛求欧拉函数"></a>欧拉筛求欧拉函数</h5><p>还记不下来，但先把板子搞下来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">50</span>;<span class="keyword">int</span> phi[maxn], pri[maxn], cnt;<span class="keyword">bool</span> vis[maxn];<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    phi[<span class="number">1</span>] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;        <span class="keyword">if</span> (!vis[i]) &#123;            phi[i] = i - <span class="number">1</span>;            pri[++cnt] = i;        &#125;        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;            <span class="keyword">if</span> (<span class="number">1ll</span> * i * pri[j] &gt; n) <span class="keyword">break</span>;            vis[i * pri[j]] = <span class="number">1</span>;            <span class="keyword">if</span> (i % pri[j]) &#123;                phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);            &#125;            <span class="keyword">else</span> &#123;                phi[i * pri[j]] = phi[i] * pri[j];                <span class="keyword">break</span>;            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉定理-amp-费马小定理"><a href="#欧拉定理-amp-费马小定理" class="headerlink" title="欧拉定理&amp;费马小定理"></a>欧拉定理&amp;费马小定理</h3><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>若$p$为素数，$gcd(a,p)=1$，则$a^{p-1}\equiv 1(mod\ p)$。</p>
<p>应用：和快速幂结合求乘法逆元</p>
<h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>若$gcd(a,n)=1$，则<br>$$<br>a^{\varphi(m)}\equiv1(mod\ m)<br>$$</p>
<h4 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h4><p>$$<br>a^b=\begin{cases}<br>    a^{b; mod; \varphi(p)},\ \qquad\ \ \qquad gcd(a,p)=1 \<br>    a^b,gcd(a,p)\neq 1,\qquad b&lt;\varphi(p)\<br>    a^{b\ mod\ \varphi(p)+\varphi(p)},\qquad\quad gcd(a,p)\neq1,b\geq\varphi(p)<br>    \end{cases}<br>    (mod\ p)<br>$$</p>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>设$a,b$是不全为零的整数，则存在整数$x,y$，使得$ax+by=d$</p>
<p>$d=gcd(a,b)$是形如$ax+by(x,y\in Z)$中的的最小者。</p>
<p><a href="https://oi-wiki.org/math/number-theory/bezouts/">证明链接</a></p>
<p>进一步结论</p>
<p>设自然数a、b和整数n。a与b互素。考察不定方程：<br>$$<br>ax+by=n<br>$$<br>其中$x$和$y$为自然数。如果方程有解，称$n$可以被$a、b$表示。</p>
<p>记$C=ab-a-b$。由$a$与$b$互素，可得$C$必然为奇数。则有结论：</p>
<p><strong>对任意的整数<em>n</em>，<em>n</em>与<em>C - n</em>中有且仅有一个可以被表示</strong></p>
<p>即：可表示的数与不可表示的数在区间$[0,C]$对称（关于C的一半对称）。负数不可被表示，大于$C$的数可被表示。很明显0是可以被表示的，所以$C$是不可被表示的。</p>
<h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>重新观察方程$ax+by=n$，将其看成一条直线。直线与两坐标轴在第一象限围成三角形，当$n&lt;ab$时，这条直线在点$(1,1)$下方，所以至多只能经过一个整点${(1,0),(0,1)}$。</p>
<p>根据上述讨论：当$n$可悲表示时，直线恰好经过一个整点；当$n$不可被表示时，直线不经过整点（在第一象限）。</p>
<p>因此，小于等于$n$的能被表示的非负整数的数量，恰好就是直线$ax+by=n$（含）与两坐标轴（含）在第一象限围成三角形覆盖的整点的个数。</p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>如果一个线性同余方程$ax\equiv 1(mod\ b)$，则$x$称为$a\ mod\ b$的逆元，记作$a^{-1}$</p>
<h4 id="扩展欧几里得法"><a href="#扩展欧几里得法" class="headerlink" title="扩展欧几里得法"></a>扩展欧几里得法</h4><p>使用要求：<strong>a与b互质</strong></p>
<p>由于扩展欧几里得可以求出$ax+by=gcd(a,b)$的一组特殊解，而乘法和加法运算在取模意义下也成立，所以可以得到<br>$$<br>ax+ 0=gcd(a,b)\ mod\ b<br>$$<br>若$a$与$b$互质，那么<br>$$<br>ax=1 \ mod \ b<br>$$<br>那么就得到了$a$在模$b$意义下的逆元$x$。</p>
<h4 id="费马小定理法"><a href="#费马小定理法" class="headerlink" title="费马小定理法"></a>费马小定理法</h4><p>使用要求：<strong>模数是质数</strong></p>
<p>由于<br>$$<br>a^{p-1}\equiv1(mod\ p)\to a×a^{p-2}\equiv1(mod\ p)<br>$$<br>所以当模数是质数的时候，我们直接求$a^{p-2}$即为$a$的逆元。由于一般会是大质数，所以会和快速幂集合使用。</p>
<h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><p>求$[1,n]$中每个关于$p$的逆元。时间复杂度$O(n)$<br>$$<br>i^{-1}\equiv \begin{cases}<br>1,\qquad \qquad \qquad \qquad \quad if\ i=1\<br>-\lfloor \frac{p}{i} \rfloor (p\ mod\ i)^{-1},\qquad otherwises\<br>\end{cases}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;    inv[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)(p - p / i) * inv[p % i] % p;&#125;</span><br></pre></td></tr></table></figure>

<p>求任意$n$个数的逆元$(1\leq a_i&lt;p)$。时间复杂度$O(n+log\ p)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = s[i - <span class="number">1</span>] * a[i] % p;sv[n] = <span class="built_in">qpow</span>(s[n], p - <span class="number">2</span>);<span class="comment">// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.for (int i = n; i &gt;= 1; --i) sv[i - 1] = sv[i] * a[i] % p;for (int i = 1; i &lt;= n; ++i) inv[i] = sv[i] * s[i - 1] % p;</span></span><br></pre></td></tr></table></figure>

<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><h4 id="前置知识：积性函数、-Dirichlet-卷积、莫比乌斯函数"><a href="#前置知识：积性函数、-Dirichlet-卷积、莫比乌斯函数" class="headerlink" title="前置知识：积性函数、$Dirichlet$卷积、莫比乌斯函数"></a>前置知识：积性函数、$Dirichlet$卷积、莫比乌斯函数</h4><h5 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h5><p>$$<br>\forall a,b,c\in Z,\lfloor \frac{a}{bc}\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c} \rfloor<br>$$</p>
<p>略证：<br>$$<br>\frac{a}{b}=\lfloor \frac{a}{b}\rfloor +r(0\leq r&lt;1)\<br>\downarrow\<br>\lfloor\frac{a}{bc}\rfloor=\lfloor \frac{\frac{a}{b}}{c} \rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c} +\frac{r}{c}\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c} \rfloor<br>$$</p>
<h5 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h5><p>$$<br>\forall n\in N_+,|\begin{Bmatrix} \lfloor \frac{n}{d} \rfloor|d\in N_+,d\leq n\end{Bmatrix}|\leq\lfloor 2\sqrt{n} \rfloor<br>$$</p>
<p>$|V|$表示集合$V$的个数</p>
<p>证明类似埃氏筛中$i×i\leq n$的优化</p>
<h5 id="数论分块-除法分块"><a href="#数论分块-除法分块" class="headerlink" title="数论分块/除法分块"></a>数论分块/除法分块</h5><p>考虑含有$\lfloor \frac{n}{i} \rfloor$的求和式子，在计算过程中，一部分连续的$i$对应的值会相同，一次性把这些值全部算进去可加快计算。</p>
<h5 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h5><p>若函数$f(n)$满足$f(1)=1$且$\forall x,y\in N_+,gcd(x,y)=1$都有$f(xy)=f(x)f(y)$，则$f(n)$为积性函数。</p>
<p>若函数$f(n)$满足$f(1)=1$且$\forall x,y\in N_+$都有$f(xy)=f(x)f(y)$，则$f(n)$为完全积性函数。</p>
<p><strong>性质</strong></p>
<p>若$f(x)$和$g(x)$均为积性函数，则以下函数也为积性函数：<br>$$<br>h(x)=f(x^p)\<br>h(x)=f^p(x)\<br>h(x)=f(x)g(x)\<br>h(x)=\sum_{d|x}f(d)g(\frac{x}{d})<br>$$<br>设$x=\prod p_i^{k_i}$</p>
<p>若$F(x)$为积性函数，则有$F(x)=\prod F(p_i^{k_i})$。</p>
<p>若$F(x)$为完全积性函数，则有$F(x)=\prod F(p_i)^{k_i}$</p>
<p><strong>e.g.</strong></p>
<p>单位函数：$\epsilon (n)=[n=1]$（完全积性）</p>
<p>恒等函数：$id_k(n)=n^k$，$id_1(n)$通常记作$id(n)$。（完全积性）</p>
<p>常数函数：$1(n)=1$（完全积性）</p>
<p>除数函数：$\sigma_k(n)=\sum_(d|n)d^k\sigma_0(n)$，通常记作$d(n)$或$\tau(n)$，$\sigma_1(n)$通常记作$\sigma(n)$</p>
<p>欧拉函数：$\phi(n)=\sum_{i=1}^n[gcd(i,n)=1]$</p>
<p>莫比乌斯函数：$\mu(n)=\begin{cases} 1\qquad\qquad\qquad n=1\0\qquad\qquad\qquad \exist d&gt;1,d^2|n\(-1)^\omega(n) \qquad\ \  otherwise\end{cases}$，其中$\omega(n)$表示$n$的本质不同质因子个数，它是一个加性函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">此处加性函数指数论上的加性函数（Additive <span class="function"><span class="keyword">function</span>）。对于加性函数<span class="title">f</span>,当整数<span class="title">a</span>,<span class="title">b</span>互质时，均有<span class="title">f</span>(<span class="params">ab</span>)=<span class="title">f</span>(<span class="params">a</span>)+<span class="title">g</span>(<span class="params">b</span>)。应与代数中的加性函数(<span class="params">Additive map</span>)区分</span></span><br></pre></td></tr></table></figure>

<h4 id="Dirchlet卷积"><a href="#Dirchlet卷积" class="headerlink" title="Dirchlet卷积"></a>Dirchlet卷积</h4><p>对于两个数论函数$f(x)$和$g(x)$，则他们的迪利克雷卷积得到的结果$h(x)$定义为<br>$$<br>h(x)=\sum_{d|x}f(d)g(\frac{x}{d})=\sum_{ab=x}f(x)f(b)<br>$$<br>上式可简记为：<br>$$<br>h=f*g<br>$$<br>迪利克雷卷积是数论函数的重要运算，数论函数的许多性质都是通过这个运算挖掘出来的。</p>
<p><strong>性质</strong></p>
<p>交换律：$f<em>g=g</em>f$</p>
<p>结合律：$(f<em>g)<em>h=f</em>(g</em>h)$</p>
<p>分配律：$(f+g)<em>h=f</em>h+g*h$</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p><strong>消元法说明</strong></p>
<p>消元法是将方程组中的以方程的未知数用含有另一未知数的代数式表示，并将其带入到另一方程中，这就消去了一未知数，得到一解；或将方程组中的一方程倍乘某个常数加到另一方程中去，也可打到消去一未知数的目的。</p>
<p><strong>消元法理论核心</strong></p>
<p>Ⅰ    两方程互换，解不变。</p>
<p>Ⅱ    一方程乘以非零数$k$，解不变。</p>
<p>Ⅲ    一方程乘以数$k$加上另一方程，解不变。</p>
<p><strong>高斯消元法思想概念</strong></p>
<p>①在消元法中，参与计算和发生变化的是方程中各变量的系数</p>
<p>②各变量并未参与计算，并且没有发生改变</p>
<p>③可以利用系数的位置表示变量，从而省略变量</p>
<p>④在计算中将变量简化省略，方程的解不变</p>
<p><del><strong>高斯消元五步骤法</strong></del>直接模拟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;<span class="keyword">double</span> a[maxn][maxn];<span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;    <span class="keyword">int</span> n;    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n + <span class="number">1</span>;j++) &#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;        <span class="comment">//这里一定要循环n次，最后一次是用来判断最后一波是否无解        int id = i;        for (int j = i + 1;j &lt;= n;j++) &#123;            if (fabs(a[j][i]) &gt; fabs(a[id][j])) &#123;                id = j;            &#125;        &#125;        swap(a[i], a[id]);        if (fabs(a[i][i]) &lt; eps) &#123;            cout &lt;&lt; &quot;No Solution\n&quot;;            return;        &#125;        for (int j = i + 1;j &lt;= n;j++) &#123;            double temp = a[j][i] / a[i][i];            for (int k = i;k &lt;= n + 1;k++) &#123;                a[j][k] -= temp * a[i][k];            &#125;            a[j][i] = 0;        &#125;    &#125;    double ans[maxn] = &#123;&#125;;    ans[n] = a[n][n + 1] / a[n][n];    for (int i = n - 1;i &gt;= 1;i--) &#123;        double temp = a[i][n + 1];        for (int j = n;j &gt;= i + 1;j--) &#123;            temp -= ans[j] * a[i][j];        &#125;        ans[i] = temp / a[i][i];    &#125;    for (int i = 1;i &lt;= n;i++) &#123;        printf(&quot;%.2f\n&quot;, ans[i]);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
